= Translation of Higher-Order Constructs

What are the higher-order constructs? I believe this is a complete list:

C1. Terms as formulas: x && y, where x, y : prop
C2. Formulas within terms: p (x a = x) -> p true
C3. Lambda-abstractions: (fun x y. y + x) = (+)
C4. Higher-order arguments: map f [x] = [f x]
C5. Partial function applications: f = g -> f x = g x
C6. Higher-order quantification: forall x. exists f. f x = x

C1 and C2 are not an issue for SMT-LIB or Nunchaku already today.

== Lambda-Abstractions

C3 (lambda-abstractions) can be eliminated by extensionality and by a
transformation that performs lambda-lifting (defunctionalization,
supercombinators).

=== Extensionality

Applying extensionality in this case means translating

----
lhs = rhs
----

where either lhs or rhs is a lambda-abstraction (not otherwise!) to

----
forall x. lhs x = rhs x
----

Example:

----
empty = (fun x. false)
----

to

----
forall x. empty x = false
----

=== Lambda-Lifting

Lambda-lifting introduces a new function symbol corresponding to each
lambda-abstraction. That symbol takes all the free variables (not cons of the
lambda-abstractions as argument, before taking the lambda argument itself.

Example:

----
... forall u v. P (fun x. fun y. F x y u v) ...
----

becomes

----
... forall u v. P (lifted1 u v) ...

rec lifted1 :=
  lifted1 u v = (fun x. fun y. F x y u v).
----

which by extensionality becomes

----
... forall u v. P (lifted1 u v) ...

rec lifted1 :=
  lifted1 u v x y = F x y u v.
----

A single definition ("lifted1") is sufficient for an iterated
lambda-abstraction (here "fun x. fun y. ...").

== Higher-Order Arguments and Partial Function Applications

C4 (higher-order arguments) and C5 (partial function applications) go hand
in hand. In fact, C6 (higher-order quantification) is also a prerequisite for
C4, but we will study it in more generality below.

Specialization is a neat trick that takes care of some higher-order
quantifiers, e.g., the arguments to a "map" function. We will assume that it
has been applied already and look at the remaining higher-order arguments.

*TODO*

== Higher-Order Quantification

=== Skolemization

If we are lucky, skolemization eliminates a higher-order quantifier before it
causes any trouble.

*TODO*
